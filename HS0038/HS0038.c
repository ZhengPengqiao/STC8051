#include "HS0038.h"

unsigned char irflag = 0;  //红外接收标志
__xdata unsigned char ircode[4];   //红外代码接收缓冲区

/*******************************************************************************
 * 函数名称 : hs0038Init
 * 函数介绍 : 初始化
 * 参数介绍 : 无
 * 返回值  :  无
 ******************************************************************************/
void hs0038Init()
{
	EA = 1;
	HS0038 = 1;      //确保红外线引脚被释放
	TMOD &= 0x0F;    //清楚T1控制位
	TMOD |= 0x10;    //配置T1为模式1
	TR1 = 0;         //停止T1定时器
	ET1 = 0;         //禁止T1中断
	IT1 = 1;         //设置INT1为负边沿中断
	EX1 = 1;         //使能INT1中断
}


/*******************************************************************************
 * 函数名称 : getHightTime
 * 函数介绍 : 得到引脚高电平持续的时间
 * 参数介绍 : 无
 * 返回值  :  持续时间
 ******************************************************************************/
unsigned int getHightTime()
{
	TH1 = 0;
	TL1 = 0;  //清空计数器
	TR1 = 1;        //开启计数器
	while(HS0038)   //判断引脚电位,直到转为低电平为止
	{
		if(TH1 > 0x40)   //当计数器超过18MS时,强行退出,为了避免因为信号异常造成的死锁
		{
			break;
		}
	}
	TR1 = 0;        //停止计数器
	return (TH1*256 + TL1);   //返回计数的值 //不能使用移位
}

/*******************************************************************************
 * 函数名称 : getLowTime
 * 函数介绍 : 得到引脚低电平持续时间
 * 参数介绍 : 无
 * 返回值  :  低电平持续时间
 ******************************************************************************/
unsigned int getLowTime()
{
	TH1 = 0;
	TL1 = 0;  //清空计数器
	TR1 = 1;        //开启计数器
	while(!HS0038)   //判断引脚电位,直到转为高电平为止
	{
		if(TH1 > 0x40)   //当计数器超过18MS时,强行退出,为了避免因为信号异常造成的死锁
		{
			break;
		}
	}
	TR1 = 0;        //停止计数器
	return (TH1*256 + TL1);   //返回计数的值
}



/*******************************************************************************
 * 函数名称 : EXINT1_ISR
 * 函数介绍 : 外部中断1的中断函数
 * 参数介绍 : 无
 * 返回值  :  无
 ******************************************************************************/
void EXINT1_ISR() __interrupt 2
{
	unsigned char i,j;
	unsigned char byt = 0;
	unsigned int time;
	
	//接收并判断引导码的9ms低电平
	time  = getLowTime();
	if( (time < 7833) || (time > 8755) )  //时间判定范围为8.5ms ~ 9.5ms
	{
		IE1 = 0;  //超过洗范围说明为误码,直接退出,退出前清零INT1中断标志位
		return ;
	}
	
	 //判断引导码的4.5ms的高电平
	time = getHightTime();
	if( (time < 3686) || (time > 4608) )   //时间判定范围在4.0~5.0ms
	{
		IE1 = 0;
		return;
	}
	
	//接受并判定后续的4个字节
	for(i = 0; i < 4; i++)  //循环接收四个字节
	{
		for(j = 0; j < 8; j++)  //循环接收判定每字节的八个位
		{
			//接收判定每bit的560us低电平
			time = getLowTime();
			if( (time < 313) || (time > 718) ) //时间判定范围是340~780us
			{
				IE1 = 0;
				return;
			}
			
			//接收每bit的高电平时间,判定该BIT的值
			time = getHightTime();
			if( (time > 313) && (time < 718) ) //时间判定范围是340~780us
			{									//在此范围说明该bit值为0
				byt >>= 1;						//因地位在前,所以数据右移,高位为0
			}
			else if( (time > 1345) && (time < 1751) )  //时间判定在1460~1900us
			{
				byt >>= 1;        //在此范围说明该bit值为1,因低位在先,所以数据右移
				byt |= 0x80;      //将高位置1
			}
			else                  //不在上述范围说明错误,直接退出
			{
				IE1 = 0;
				return;
			}
			
		}
		ircode[i] = byt;  //接收完一个字节后,将接收到的数据保存在缓冲区中
	}
	irflag = 1;           //接收完毕后设置该为
	IE1 = 0;              //清楚中断标志位
}
